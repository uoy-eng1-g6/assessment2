<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">uk.ac.york.student.assets.map</a> &gt; <span class="el_source">MapManager.java</span></div><h1>MapManager.java</h1><pre class="source lang-java linenums">package uk.ac.york.student.assets.map;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.maps.MapLayer;
import com.badlogic.gdx.maps.objects.PolygonMapObject;
import com.badlogic.gdx.maps.objects.RectangleMapObject;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.TmxMapLoader;
import java.util.HashMap;
import java.util.List;
import lombok.experimental.UtilityClass;

/**
 * This utility class manages the loading and storage of TiledMap objects.
 * It uses a MapOfSuppliers to store the maps, allowing for lazy loading.
 */
// CHANGE refactor class to use simple hashmap cache with better object disposal to fix many issues
@UtilityClass
<span class="nc" id="L20">public final class MapManager {</span>
<span class="fc" id="L21">    public static final List&lt;String&gt; MAP_NAMES =</span>
<span class="fc" id="L22">            List.of(&quot;map&quot;, &quot;inside_house&quot;, &quot;inside_pub&quot;, &quot;inside_library&quot;, &quot;blankMap&quot;);</span>

    static TmxMapLoader MAP_LOADER;
    static TmxMapLoader.Parameters MAP_LOADER_PARAMETERS;

<span class="fc" id="L27">    static final HashMap&lt;String, TiledMap&gt; cachedMaps = new HashMap&lt;&gt;();</span>
<span class="fc" id="L28">    static final HashMap&lt;String, MapObjectsPositionData&gt; cachedMapObjectData = new HashMap&lt;&gt;();</span>

    static {
<span class="fc" id="L31">        MAP_LOADER = new TmxMapLoader();</span>
<span class="fc" id="L32">        MAP_LOADER_PARAMETERS = new TmxMapLoader.Parameters();</span>
<span class="fc" id="L33">        MAP_LOADER_PARAMETERS.textureMinFilter = Texture.TextureFilter.Nearest;</span>
<span class="fc" id="L34">        MAP_LOADER_PARAMETERS.textureMagFilter = Texture.TextureFilter.Nearest;</span>
<span class="fc" id="L35">    }</span>

    static String getMapPath(String mapName) {
<span class="nc" id="L38">        return &quot;map/&quot; + mapName + &quot;.tmx&quot;;</span>
    }

    public static TiledMap getMap(String mapName) {
<span class="fc bfc" id="L42" title="All 2 branches covered.">        if (cachedMaps.containsKey(mapName)) {</span>
<span class="fc" id="L43">            return cachedMaps.get(mapName);</span>
        }

<span class="fc" id="L46">        var map = MAP_LOADER.load(getMapPath(mapName), MAP_LOADER_PARAMETERS);</span>
<span class="fc" id="L47">        cachedMaps.put(mapName, map);</span>
<span class="fc" id="L48">        return map;</span>
    }

    // CHANGE new method
    static void loadCollisionObjectsFromMapLayer(
            MapObjectsPositionData data, int tileWidth, int tileHeight, MapLayer mapLayer) {
<span class="fc bfc" id="L54" title="All 2 branches covered.">        for (var object : mapLayer.getObjects()) {</span>
            float x, y;
            float[] vertices;
<span class="fc bfc" id="L57" title="All 2 branches covered.">            if (object instanceof RectangleMapObject) {</span>
<span class="fc" id="L58">                var rectangleObject = (RectangleMapObject) object;</span>
<span class="fc" id="L59">                var rectangle = rectangleObject.getRectangle();</span>

<span class="fc" id="L61">                x = rectangle.getX();</span>
<span class="fc" id="L62">                y = rectangle.getY();</span>
<span class="fc" id="L63">                var width = rectangle.getWidth();</span>
<span class="fc" id="L64">                var height = rectangle.getHeight();</span>

<span class="fc" id="L66">                vertices = new float[] {x, y, x, y + height, x + width, y + height, x + width, y};</span>

<span class="fc" id="L68">                x = x / tileWidth;</span>
<span class="fc" id="L69">                y = y / tileHeight;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            } else if (object instanceof PolygonMapObject) {</span>
<span class="fc" id="L71">                var polygonObject = (PolygonMapObject) object;</span>
<span class="fc" id="L72">                var polygon = polygonObject.getPolygon();</span>

<span class="fc" id="L74">                x = polygon.getX() / tileWidth;</span>
<span class="fc" id="L75">                y = polygon.getY() / tileHeight;</span>
<span class="fc" id="L76">                vertices = polygon.getTransformedVertices();</span>
<span class="fc" id="L77">            } else {</span>
                // Can there be another type of map object?
<span class="nc" id="L79">                System.out.printf(</span>
<span class="nc" id="L80">                        &quot;Unrecognised collision object: %s&quot;, object.getClass().getSimpleName());</span>
<span class="nc" id="L81">                continue;</span>
            }

            // Normalize the vertices to tile scale instead of pixel scale
            // - Box2D prefers smaller worlds which allows for smaller velocities
<span class="fc bfc" id="L86" title="All 2 branches covered.">            for (var i = 0; i &lt; vertices.length; i += 2) {</span>
<span class="fc" id="L87">                vertices[i] /= tileWidth;</span>
<span class="fc" id="L88">                vertices[i] -= x;</span>
<span class="fc" id="L89">                vertices[i + 1] /= tileHeight;</span>
<span class="fc" id="L90">                vertices[i + 1] -= y;</span>
            }

<span class="fc" id="L93">            data.getCollisionObjects().add(new MapObjectsPositionData.CollisionObjectData(x, y, vertices));</span>
<span class="fc" id="L94">        }</span>
<span class="fc" id="L95">    }</span>

    // CHANGE new method
    static void loadActionableObjectDataFromMapLayer(
            MapObjectsPositionData data, int tileWidth, int tileHeight, MapLayer mapLayer) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (var object : mapLayer.getObjects()) {</span>
<span class="fc" id="L101">            Boolean actionable = object.getProperties().get(&quot;actionable&quot;, Boolean.class);</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            if (Boolean.FALSE.equals(actionable)) continue;</span>

<span class="fc" id="L104">            var rectangleObject = (RectangleMapObject) object;</span>
<span class="fc" id="L105">            var rectangle = rectangleObject.getRectangle();</span>

<span class="fc" id="L107">            data.getActionableObjects()</span>
<span class="fc" id="L108">                    .add(new MapObjectsPositionData.ActionableObjectData(</span>
                            rectangle.x / tileWidth,
                            rectangle.y / tileHeight,
                            rectangle.width / tileWidth,
                            rectangle.height / tileHeight,
                            object));
<span class="fc" id="L114">        }</span>
<span class="fc" id="L115">    }</span>

    // CHANGE new method
    public static MapObjectsPositionData getMapObjectData(String mapName) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (cachedMapObjectData.containsKey(mapName)) {</span>
<span class="fc" id="L120">            return cachedMapObjectData.get(mapName);</span>
        }

<span class="fc" id="L123">        var map = getMap(mapName);</span>
<span class="fc" id="L124">        var backgroundLayer = (TiledMapTileLayer) map.getLayers().get(0);</span>
<span class="fc" id="L125">        var tileWidth = backgroundLayer.getTileWidth();</span>
<span class="fc" id="L126">        var tileHeight = backgroundLayer.getTileHeight();</span>

<span class="fc" id="L128">        var data = new MapObjectsPositionData();</span>

<span class="fc" id="L130">        var collisionLayer = map.getLayers().get(&quot;collisions&quot;);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (collisionLayer != null) {</span>
<span class="fc" id="L132">            loadCollisionObjectsFromMapLayer(data, tileWidth, tileHeight, collisionLayer);</span>
        }
<span class="fc" id="L134">        var actionableObjectLayer = map.getLayers().get(&quot;gameObjects&quot;);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (actionableObjectLayer != null) {</span>
<span class="fc" id="L136">            loadActionableObjectDataFromMapLayer(data, tileWidth, tileHeight, actionableObjectLayer);</span>
        }

<span class="fc" id="L139">        cachedMapObjectData.put(mapName, data);</span>
<span class="fc" id="L140">        return data;</span>
    }

    public static void dispose() {
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (var map : cachedMaps.values()) {</span>
<span class="fc" id="L145">            map.dispose();</span>
<span class="fc" id="L146">        }</span>
<span class="fc" id="L147">        cachedMaps.clear();</span>
<span class="fc" id="L148">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>