<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MainMenuScreen.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">uk.ac.york.student.screens</a> &gt; <span class="el_source">MainMenuScreen.java</span></div><h1>MainMenuScreen.java</h1><pre class="source lang-java linenums">package uk.ac.york.student.screens;

import static com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeIn;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Image;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import lombok.Getter;
import org.jetbrains.annotations.NotNull;
import uk.ac.york.student.GdxGame;
import uk.ac.york.student.assets.skins.SkinManager;
import uk.ac.york.student.assets.skins.Skins;
import uk.ac.york.student.audio.sound.GameSound;
import uk.ac.york.student.audio.sound.SoundManager;
import uk.ac.york.student.audio.sound.Sounds;
import uk.ac.york.student.settings.DebugScreenPreferences;
import uk.ac.york.student.settings.GamePreferences;
import uk.ac.york.student.settings.MainMenuCloudsPreferences;

/**
 * The MainMenuScreen class extends the BaseScreen class and represents the main menu screen of the game.
 * It contains a Stage object, which is used to handle input events and draw the elements of the screen.
 * The class overrides the methods of the Screen interface, which are called at different points in the game's lifecycle.
 * The MainMenuScreen class also includes several private fields for textures, images, skins, sounds, and settings used in the main menu.
 * It provides three constructors that allow for different levels of customization of the fade-in effect when the main menu screen is shown.
 * The class also includes several methods for handling the rendering and animation of the main menu screen, as well as the actions performed when different buttons are clicked.
 */
public class MainMenuScreen extends BaseScreen {
    /**
     * The {@link Stage} instance for the {@link MainMenuScreen} class.
     * This instance is used to handle input events and draw the elements of the screen.
     */
<span class="nc" id="L53">    @Getter</span>
    private final Stage processor;

    /**
     * A boolean value that determines whether the screen should fade in when it is shown.
     * If true, the screen will fade in; if false, it will not.
     */
    private final boolean shouldFadeIn;

    /**
     * The time in seconds for the fade-in effect when the screen is shown.
     * This value is used only if {@link MainMenuScreen#shouldFadeIn} is true.
     */
    private final float fadeInTime;

    /**
     * The Texture instance for the background of the {@link MainMenuScreen}.
     * This texture is loaded from the &quot;images/MapOverview.png&quot; file.
     */
<span class="nc" id="L72">    private final Texture backgroundTexture = new Texture(Gdx.files.internal(&quot;images/MapOverview.png&quot;));</span>

    /**
     * The Texture instance for the vignette effect on the {@link MainMenuScreen}.
     * This texture is loaded from the &quot;images/Vignette.png&quot; file.
     */
<span class="nc" id="L78">    private final Texture vignetteTexture = new Texture(Gdx.files.internal(&quot;images/Vignette.png&quot;));</span>

    /**
     * The Texture instance for the logo on the {@link MainMenuScreen}.
     * This texture is loaded from the &quot;images/logo/b/logo.png&quot; file.
     * The subfolder is &quot;b&quot; to represent version B of the logo
     */
<span class="nc" id="L85">    private final Texture cookeLogo = new Texture(Gdx.files.internal(&quot;images/logo/b/logo.png&quot;));</span>

    /**
     * The Texture instance for the clouds on the {@link MainMenuScreen}.
     * This texture is loaded from the &quot;images/CloudsFormatted.png&quot; file.
     */
<span class="nc" id="L91">    private final Texture clouds = new Texture(Gdx.files.internal(&quot;images/CloudsFormatted.png&quot;));</span>

    /**
     * The Image instance for the clouds on the {@link MainMenuScreen}.
     * This image is created from the clouds texture.
     */
<span class="nc" id="L97">    private final Image cloudsImage = new Image(new TextureRegionDrawable(new TextureRegion(clouds)));</span>

    /**
     * The GameSound instance for the button click sound on the {@link MainMenuScreen}.
     * This sound is loaded from the {@link SoundManager} using the {@link Sounds#BUTTON_CLICK} sound.
     */
    // CHANGE fix logic slightly for changes to SkinManager
<span class="nc" id="L104">    private final GameSound buttonClick = SoundManager.getInstance().getSound(Sounds.BUTTON_CLICK);</span>

    /**
     * A boolean value that determines whether the clouds are enabled on the {@link MainMenuScreen}.
     * This value is retrieved from the {@link MainMenuCloudsPreferences} in the {@link GamePreferences}.
     * If true, the clouds will be displayed on the {@link MainMenuScreen}; if false, they will not.
     */
<span class="nc" id="L111">    private final boolean cloudsEnabled =</span>
<span class="nc" id="L112">            ((MainMenuCloudsPreferences) GamePreferences.MAIN_MENU_CLOUDS.getPreference()).isEnabled();</span>

    /**
     * The speed of the clouds on the {@link MainMenuScreen}.
     * This value is retrieved from the {@link MainMenuCloudsPreferences} in the {@link GamePreferences}.
     * It represents the speed at which the clouds move across the {@link MainMenuScreen}.
     */
<span class="nc" id="L119">    private final float cloudsSpeed =</span>
<span class="nc" id="L120">            ((MainMenuCloudsPreferences) GamePreferences.MAIN_MENU_CLOUDS.getPreference()).getSpeed();</span>

    // CHANGE update for changes to SkinManager
<span class="nc" id="L123">    private final Skin skin = SkinManager.getSkin(Skins.CRAFTACULAR);</span>

    /**
     * Constructor for the {@link MainMenuScreen} class.
     * This constructor initializes the {@link MainMenuScreen} with the provided game, shouldFadeIn value, and fadeInTime.
     * It also initializes the processor with a new {@link Stage} with a {@link ScreenViewport}, and sets this processor as the input processor for {@link Gdx}.
     * Additionally, it initializes the {@link MainMenuScreen#executorService} with a new single thread scheduled executor.
     * @param game the {@link GdxGame} instance representing the game
     * @param shouldFadeIn a boolean value that determines whether the screen should fade in when it is shown
     * @param fadeInTime the time in seconds for the fade-in effect when the screen is shown
     */
    public MainMenuScreen(GdxGame game, boolean shouldFadeIn, float fadeInTime) {
<span class="nc" id="L135">        super(game);</span>
<span class="nc" id="L136">        this.shouldFadeIn = shouldFadeIn;</span>
<span class="nc" id="L137">        this.fadeInTime = fadeInTime;</span>
<span class="nc" id="L138">        processor = new Stage(new ScreenViewport());</span>
<span class="nc" id="L139">        Gdx.input.setInputProcessor(processor);</span>
<span class="nc" id="L140">        executorService = Executors.newSingleThreadScheduledExecutor();</span>
<span class="nc" id="L141">    }</span>

    public MainMenuScreen(GdxGame game, boolean shouldFadeIn) {
<span class="nc" id="L144">        this(game, shouldFadeIn, 0.75f);</span>
<span class="nc" id="L145">    }</span>

    /**
     * The Direction enum represents the four cardinal directions: UP, DOWN, LEFT, and RIGHT.
     * It is used in the {@link MainMenuScreen} class to specify the direction of certain animations and movements.
     */
<span class="nc" id="L151">    public enum Direction {</span>
<span class="nc" id="L152">        UP,</span>
<span class="nc" id="L153">        DOWN,</span>
<span class="nc" id="L154">        LEFT,</span>
<span class="nc" id="L155">        RIGHT</span>
    }

    /**
     * This method is used to zoom and move an actor in a specified direction.
     * The actor is scaled up and moved in the direction specified by the 'direction' parameter.
     * The scaling and movement are performed simultaneously over a duration of 1 second.
     * The distance of the movement is 800 units.
     *
     * @param actor The actor to be zoomed and moved. This should be an instance of the {@link Actor} class or any of its subclasses.
     * @param direction The direction in which the actor should be moved. This should be one of the values of the {@link MainMenuScreen.Direction} enum.
     */
    public void zoomAndMove(@NotNull Actor actor, @NotNull Direction direction) {
        // Create a new Vector2 instance to store the movement vector.
<span class="nc" id="L169">        Vector2 vector = new Vector2();</span>

        // Set the scale factor for the zoom effect.
<span class="nc" id="L172">        float scale = 2;</span>

        // Set the duration of the zoom and move actions in seconds.
<span class="nc" id="L175">        int duration = 1;</span>

        // Set the distance of the movement in units.
<span class="nc" id="L178">        int distance = 800;</span>

        // Determine the movement vector based on the specified direction.
<span class="nc bnc" id="L181" title="All 5 branches missed.">        switch (direction) {</span>
            case UP:
<span class="nc" id="L183">                vector.set(0, distance);</span>
<span class="nc" id="L184">                break;</span>
            case DOWN:
<span class="nc" id="L186">                vector.set(0, -distance);</span>
<span class="nc" id="L187">                break;</span>
            case LEFT:
<span class="nc" id="L189">                vector.set(-distance, 0);</span>
<span class="nc" id="L190">                break;</span>
            case RIGHT:
<span class="nc" id="L192">                vector.set(distance, 0);</span>
                break;
        }

        // Set the origin of the actor to its center. This is necessary for the zoom effect to work correctly.
<span class="nc" id="L197">        actor.setOrigin(Align.center);</span>

        // Add the zoom and move actions to the actor. These actions will be performed simultaneously.
<span class="nc" id="L200">        actor.addAction(Actions.parallel(</span>
<span class="nc" id="L201">                Actions.scaleTo(scale, scale, duration), // Scale the actor to the specified scale factor.</span>
<span class="nc" id="L202">                Actions.moveBy(vector.x, vector.y, duration) // Move the actor by the specified vector.</span>
                ));
<span class="nc" id="L204">    }</span>

    /**
     * An {@link AtomicReference} to a {@link Float} value representing the alpha value for fade effects.
     * This value is used to control the transparency of certain elements during fade in/out animations.
     * The initial value is set to 1f, representing full opacity.
     */
<span class="nc" id="L211">    private final AtomicReference&lt;Float&gt; alpha = new AtomicReference&lt;&gt;(1f);</span>

    /**
     * A {@link ScheduledExecutorService} instance used for scheduling tasks to be executed after a certain delay, or at fixed intervals.
     * This is used in the {@link MainMenuScreen} class to schedule tasks such as fade out animations or other time-dependent actions.
     */
    private final ScheduledExecutorService executorService;

    /**
     * This method is used to create a fade out effect over a specified duration.
     * The fade out effect is achieved by gradually reducing the alpha value of the elements to be faded.
     * The alpha value is updated at fixed intervals until it reaches 0, at which point it is maintained at 0.
     * The duration of the fade out effect is 1 second.
     * The method uses a {@link ScheduledExecutorService}, specifically {@link MainMenuScreen#executorService}, to schedule the updates to the alpha value and to cancel the updates after the specified duration.
     */
    public void fadeOut() {
        // Set the duration of the fade out effect in seconds.
<span class="nc" id="L228">        int duration = 1;</span>

        // Calculate the total number of reductions in the alpha value that will be performed during the fade out
        // effect.
<span class="nc" id="L232">        long totalReductions = (long) (1 / 0.01);</span>

        // Calculate the period between each reduction in the alpha value in milliseconds.
<span class="nc" id="L235">        long period = (duration * 1000) / totalReductions;</span>

        // Set the time unit for the duration of the fade out effect.
<span class="nc" id="L238">        TimeUnit timeUnit = TimeUnit.SECONDS;</span>

        // Schedule a task to be executed at fixed intervals that reduces the alpha value by 0.01.
        // The task is scheduled to start immediately and to be executed every 'period' milliseconds.
<span class="nc" id="L242">        ScheduledFuture&lt;?&gt; scheduledFuture = executorService.scheduleAtFixedRate(</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                () -&gt; alpha.updateAndGet(v -&gt; v &lt;= 0 ? 0 : v - 0.01f), 0, period, TimeUnit.MILLISECONDS);</span>

        // Schedule a task to be executed after the specified duration that cancels the updates to the alpha value.
<span class="nc" id="L246">        executorService.schedule(() -&gt; scheduledFuture.cancel(true), duration, timeUnit);</span>
<span class="nc" id="L247">    }</span>

    /**
     * This method is called when the {@link MainMenuScreen} is shown.
     * It sets up the UI elements and their actions for the main menu screen.
     * It also sets up the fade-in effect if {@link MainMenuScreen#shouldFadeIn} is true.
     */
    @Override
    public void show() {
        // If shouldFadeIn is true, set the alpha of the root actor to 0 and add a fade-in action to it.
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (shouldFadeIn) {</span>
<span class="nc" id="L258">            processor.getRoot().getColor().a = 0;</span>
<span class="nc" id="L259">            processor.getRoot().addAction(fadeIn(fadeInTime));</span>
        }

        // Create a new Table and add it to the stage.
<span class="nc" id="L263">        Table table = new Table();</span>
<span class="nc" id="L264">        table.setFillParent(true);</span>
        // If debug screen preferences are enabled, set the table to debug mode.
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (((DebugScreenPreferences) GamePreferences.DEBUG_SCREEN.getPreference()).isEnabled()) {</span>
<span class="nc" id="L267">            table.setDebug(true);</span>
        }
<span class="nc" id="L269">        processor.addActor(table);</span>

        // Create the buttons and the logo image for the main menu screen.
<span class="nc" id="L272">        TextButton playButton = new TextButton(&quot;Let Ron Cooke&quot;, skin);</span>
<span class="nc" id="L273">        TextButton preferencesButton = new TextButton(&quot;Settings&quot;, skin);</span>
<span class="nc" id="L274">        TextButton exitButton = new TextButton(&quot;Exit&quot;, skin);</span>
<span class="nc" id="L275">        Image cookeLogoImage = new Image(cookeLogo);</span>

        // Add the buttons and the logo image to the table.
<span class="nc" id="L278">        table.add(cookeLogoImage).fillX().uniformX().pad(0, 0, 150, 0);</span>
<span class="nc" id="L279">        table.row();</span>
<span class="nc" id="L280">        table.add(playButton).fillX().uniformX();</span>
<span class="nc" id="L281">        table.row().pad(10, 0, 10, 0);</span>
<span class="nc" id="L282">        table.add(preferencesButton).fillX().uniformX();</span>
<span class="nc" id="L283">        table.row();</span>
<span class="nc" id="L284">        table.add(exitButton).fillX().uniformX();</span>

        // Add listeners to the buttons.
        // The exit button plays the button click sound and exits the application.
<span class="nc" id="L288">        exitButton.addListener(new ChangeListener() {</span>
            /**
             * This method is triggered when a change event occurs on the actor, in this case, when the exit button is clicked.
             * It first plays the button click sound.
             * Then, it schedules a task to be executed after a delay of 400 milliseconds.
             * The scheduled task disposes the button click sound and exits the application.
             *
             * @param event The {@link com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent} triggered by the actor. This is not used in the method.
             * @param actor The actor that triggered the {@link com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent}. This is not used in the method.
             */
            @Override
            public void changed(ChangeEvent event, Actor actor) {
<span class="nc" id="L300">                buttonClick.play();</span>
                // CHANGE remove delay to exit button.
<span class="nc" id="L302">                Gdx.app.exit();</span>
<span class="nc" id="L303">            }</span>
        });

        // The play button plays the button click sound, moves all elements, fades out, and then switches to the game
        // screen.
<span class="nc" id="L308">        playButton.addListener(new ChangeListener() {</span>
            /**
             * This method is triggered when a change event occurs on the actor, in this case, when the play button is clicked.
             * It first plays the button click sound.
             * Then, it moves all elements (playButton, preferencesButton, exitButton, cookeLogoImage) in their respective directions.
             * After that, it initiates a fade out effect.
             * Finally, it schedules a task to be executed after a delay of 1500 milliseconds.
             * The scheduled task switches the screen to the game screen.
             *
             * @param event The {@link com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent} triggered by the actor. This is not used in the method.
             * @param actor The actor that triggered the {@link com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent}. This is not used in the method.
             */
            @Override
            public void changed(ChangeEvent event, Actor actor) {
<span class="nc" id="L322">                buttonClick.play();</span>
<span class="nc" id="L323">                zoomAndMove(playButton, Direction.DOWN);</span>
<span class="nc" id="L324">                zoomAndMove(preferencesButton, Direction.DOWN);</span>
<span class="nc" id="L325">                zoomAndMove(exitButton, Direction.DOWN);</span>
<span class="nc" id="L326">                zoomAndMove(cookeLogoImage, Direction.UP);</span>
<span class="nc" id="L327">                fadeOut();</span>
<span class="nc" id="L328">                Timer timer = new Timer();</span>
<span class="nc" id="L329">                timer.scheduleTask(</span>
<span class="nc" id="L330">                        new Timer.Task() {</span>
                            @Override
                            public void run() {
<span class="nc" id="L333">                                game.transitionScreen(Screens.GAME);</span>
<span class="nc" id="L334">                            }</span>
                        },
                        0.4f);
<span class="nc" id="L337">            }</span>
        });

        // The preferences button plays the button click sound and transitions to the preferences screen.
<span class="nc" id="L341">        preferencesButton.addListener(new ChangeListener() {</span>
            /**
             * This method is triggered when a change event occurs on the actor, in this case, when the preferences button is clicked.
             * It first plays the button click sound.
             * Then, it transitions the screen to the preferences screen.
             *
             * @param event The {@link com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent} triggered by the actor. This is not used in the method.
             * @param actor The actor that triggered the {@link com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent}. This is not used in the method.
             */
            @Override
            public void changed(ChangeEvent event, Actor actor) {
<span class="nc" id="L352">                buttonClick.play();</span>
<span class="nc" id="L353">                game.transitionScreen(Screens.PREFERENCES);</span>
<span class="nc" id="L354">            }</span>
        });

        // Declare variables for width and height
        float width;
        float height;

        // Get the width and height of the screen
<span class="nc" id="L362">        float ratio = getRatio();</span>

        // Calculate the new width and height for the background texture based on the ratio
<span class="nc" id="L365">        width = backgroundTexture.getWidth() * ratio;</span>
<span class="nc" id="L366">        height = backgroundTexture.getHeight() * ratio;</span>

        // Set the size of the clouds image to the new width and height
<span class="nc" id="L369">        cloudsImage.setSize(width, height);</span>
<span class="nc" id="L370">    }</span>

    /**
     * This method calculates and returns the ratio to maintain the aspect ratio of the background texture.
     * It first retrieves the width and height of the screen.
     * Then, it calculates the ratio of the screen width to the background texture width and the ratio of the screen height to the background texture height.
     * Finally, it returns the maximum of these two ratios to maintain the aspect ratio of the background texture.
     *
     * @return the maximum ratio to maintain the aspect ratio of the background texture
     */
    private float getRatio() {
        // Retrieve the width of the screen
<span class="nc" id="L382">        float screenWidth = Gdx.graphics.getWidth();</span>
        // Retrieve the height of the screen
<span class="nc" id="L384">        float screenHeight = Gdx.graphics.getHeight();</span>

        // Calculate the ratio of the screen width to the background texture width
<span class="nc" id="L387">        float widthRatio = screenWidth / backgroundTexture.getWidth();</span>

        // Calculate the ratio of the screen height to the background texture height
<span class="nc" id="L390">        float heightRatio = screenHeight / backgroundTexture.getHeight();</span>

        // Return the maximum ratio to maintain the aspect ratio of the background texture
<span class="nc" id="L393">        return Math.max(widthRatio, heightRatio);</span>
    }

    /**
     * A private float variable that represents the cycle of the cloud movement in the {@link MainMenuScreen}.
     * It is initially set to 0 and is incremented by the speed of the clouds each time the screen is rendered.
     * When the cycle exceeds the width of the screen, it is reset to 0.
     * This creates a continuous loop of the cloud movement across the screen.
     */
<span class="nc" id="L402">    private float cycle = 0;</span>
    /**
     * This method is responsible for rendering the {@link MainMenuScreen}
     * It first clears the screen and sets the clear color to black.
     * Then, it enables blending and sets the blend function to standard alpha blending.
     * After that, it retrieves the batch from the stage's processor and begins the batch.
     * It calculates the ratio to maintain the aspect ratio of the background texture and calculates the new width and height for the background texture based on the ratio.
     * It then draws the background texture.
     * If clouds are enabled, it animates the clouds by incrementing the cycle by the speed of the clouds and resetting the cycle to 0 if it exceeds the width of the screen.
     * It sets the position of the clouds image and the second clouds image and draws them with respect to the fade out alpha.
     * It then draws the vignette texture over the entire screen and ends the batch.
     * Finally, it updates the stage's actors and draws the stage.
     *
     * @param delta The time in seconds since the last render.
     */
    @Override
    public void render(float delta) {
        // Set the clear color to black and clear the screen.
<span class="nc" id="L420">        Gdx.gl.glClearColor(0, 0, 0, 1);</span>
<span class="nc" id="L421">        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);</span>

        // Enable blending and set the blend function to standard alpha blending.
<span class="nc" id="L424">        Gdx.gl.glEnable(GL20.GL_BLEND);</span>
<span class="nc" id="L425">        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);</span>

        // Get the batch from the stage's processor.
<span class="nc" id="L428">        Batch batch = processor.getBatch();</span>
<span class="nc" id="L429">        batch.begin();</span>

        // Calculate the ratio to maintain the aspect ratio of the background texture.
<span class="nc" id="L432">        float ratio = getRatio();</span>

        // Calculate the new width and height for the background texture based on the ratio.
<span class="nc" id="L435">        float width = backgroundTexture.getWidth() * ratio;</span>
<span class="nc" id="L436">        float height = backgroundTexture.getHeight() * ratio;</span>

        // Draw the background texture.
<span class="nc" id="L439">        batch.draw(backgroundTexture, 0, 0, width, height);</span>

        // If clouds are enabled, animate the clouds.
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (cloudsEnabled) {</span>
            // If the cycle exceeds the width of the screen, reset it to 0.
            // Otherwise, increment the cycle by the speed of the clouds.
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (cycle &gt; width) {</span>
<span class="nc" id="L446">                cycle = 0;</span>
<span class="nc" id="L447">            } else cycle += cloudsSpeed;</span>

            // Set the position of the clouds image and draw it with respect to the fade out alpha.
<span class="nc" id="L450">            cloudsImage.setPosition(cycle, 0);</span>
<span class="nc" id="L451">            cloudsImage.draw(batch, alpha.get());</span>

            // Set the position of the second clouds image and draw it with respect to the fade out alpha.
<span class="nc" id="L454">            cloudsImage.setPosition(cycle - width, 0);</span>
<span class="nc" id="L455">            cloudsImage.draw(batch, alpha.get());</span>
        }

        // Draw the vignette texture over the entire screen.
<span class="nc" id="L459">        batch.draw(vignetteTexture, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());</span>

        // End the batch.
<span class="nc" id="L462">        batch.end();</span>

        // Update the stage's actors and draw the stage.
<span class="nc" id="L465">        processor.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));</span>
<span class="nc" id="L466">        processor.draw();</span>
<span class="nc" id="L467">    }</span>

    /**
     * This method is called when the screen is resized.
     * It first updates the viewport of the stage's processor with the new width and height, and centers the camera.
     * Then, it retrieves the width and height of the screen.
     * It calculates the ratio of the screen width to the background texture width and the ratio of the screen height to the background texture height.
     * It takes the maximum of these two ratios to maintain the aspect ratio of the background texture.
     * It calculates the new width and height for the background texture based on the ratio.
     * Finally, it sets the size of the clouds image to the new width and height.
     *
     * @param width  The new width in pixels
     * @param height The new height in pixels
     */
    @Override
    public void resize(int width, int height) {
        // Update the viewport of the stage's processor with the new width and height, and center the camera.
<span class="nc" id="L484">        processor.getViewport().update(width, height, true);</span>

<span class="nc" id="L486">        float ratio = getRatio();</span>

        // Calculate the new width and height for the background texture based on the ratio.
<span class="nc" id="L489">        float newWidth = backgroundTexture.getWidth() * ratio;</span>
<span class="nc" id="L490">        float newHeight = backgroundTexture.getHeight() * ratio;</span>

        // Set the size of the clouds image to the new width and height.
<span class="nc" id="L493">        cloudsImage.setSize(newWidth, newHeight);</span>
<span class="nc" id="L494">    }</span>

    /**
     * This method is called when the application is paused, typically when it loses focus.
     * For example, this can happen when the user switches to another application or when a system dialog is shown.
     */
    @Override
<span class="nc" id="L501">    public void pause() {}</span>

    /**
     * This method is called when the application is resumed from a paused state, typically when it regains focus.
     * For example, this can happen when the user switches back to the application or when a system dialog is dismissed.
     * The application should resume all processes that were stopped in the pause() method in this method.
     */
    @Override
<span class="nc" id="L509">    public void resume() {}</span>

    /**
     * This method is called when the current screen is being hidden or replaced by another screen.
     * The application should stop all processes related to the current screen in this method to save resources.
     */
    @Override
<span class="nc" id="L516">    public void hide() {}</span>

    /**
     * This method is called when the {@link MainMenuScreen} is being disposed of.
     * It is responsible for freeing up resources and stopping any processes that were started in the MainMenuScreen.
     * It disposes of the {@link MainMenuScreen#processor}, {@link MainMenuScreen#backgroundTexture}, {@link MainMenuScreen#vignetteTexture}, {@link MainMenuScreen#cookeLogo}, and {@link MainMenuScreen#clouds}.
     * It also shuts down the {@link MainMenuScreen#executorService}.
     */
    // CHANGE removed some disposes that are still needed
    @Override
    public void dispose() {
        // Dispose of the processor
<span class="nc" id="L528">        processor.dispose();</span>
        // Dispose of the background texture
<span class="nc" id="L530">        backgroundTexture.dispose();</span>
        // Dispose of the vignette texture
<span class="nc" id="L532">        vignetteTexture.dispose();</span>
        // Dispose of the cooke logo
<span class="nc" id="L534">        cookeLogo.dispose();</span>
        // Dispose of the clouds texture
<span class="nc" id="L536">        clouds.dispose();</span>
        // Shutdown the executor service
<span class="nc" id="L538">        executorService.shutdown();</span>
<span class="nc" id="L539">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>